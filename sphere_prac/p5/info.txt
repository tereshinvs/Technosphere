Задание 5: кэш с использованием разделяемой памяти.
Что хочется получить.
Кеш-сервер позволяет сохранять и возвращать значения по их ключу. Каждому ключу может соответствовать некоторое время жизни (TTL), после истечении которого, ключ удаляется.
Родительский и дочерние процессы.
Кэш-сервер при старте создает 4 дочерних процесса, которые будут заниматься обработкой команд клиентов. Родительский процесс должен принимать клиентские соединения и передавать их дескриптор в дочерние процессы. Родительский процесс ничего не читает и не пишет в клиентское соединение. 
Передавать дескриптор можно через unix-сокет. Создать его будет удобнее при помощи вызова socketpair. Передавать дескриптор нужно через sendmsg (man sendmsg, man unix, google SCM_RIGHTS).
Также нужно создать отдельный процесс для сборки мусора. Процесс будет пробегать по существующим записям каждую секунду и удалять записи с просроченным TTL.
Разделяемая память.
Процессов-обработчиков будет несколько, поэтому данные кэша должны храниться в разделяемой памяти. Для этого можно использовать mmap, shm_open или
shmget.
Максимальная длина ключа — 32 байта, значения — 256. Общий размер кэша — 1 Мб. Это позволит хранить данные ячейками одинаковой длины и упростить работу с общей памятью.
Рекомендуется хранить значения в виде хэш-таблицы с открытой адресацией. В качестве хэш-функции можно взять std::hash<string>. Крайне нежелательно искать нужную запись линейным поиском.
Атомарность
Операции добавления и получения значения должны быть атомарны: в одну ячейку не должна производиться одновременная запись нескольких значений; чтение из ячейки не может производиться одновременно с записью. В противном случае, данные могут быть повреждены.
Для обеспечения атомарности доступа можно использовать семафоры (semget).
Протокол.
Сервер реализует текстовый протокол. Команды и ответы сервера разделяются переводом строки. 
Команд всего две:
"get <ключ>" — получить значение по ключу
"set <TTL> <ключ> <значение>" — установить значение для ключа с указанным TTL (в секундах)
Сервер отвечает либо "ok <ключ> <значение>" в случае удачной операции, либо "error <текст ошибки>" в случае неудачи.
Ключ не может содержать пробелов. И ключ, и значение не могут содержать переводов строки. В тексте команд не может встретиться нулевой символ. Для простоты реализации, эти случаи не нужно специально обрабатывать.
Последовательность действий.
Задание можно (но не обязательно) выполнять в следующей последовательности:

Реализация хэш-таблицы (get / set) в памяти, выделенной malloc-ом.

Исполнение команд get/set (без TTL) из stdin или константной строки, заданной при компиляции.

Реализация сетевого протокола. Получаем однопроцессный кэш-сервер.

Процессы-обработчики и передача клиентских соединение через unix-сокет. Получаем многопроцессный кэш-сервер, но у каждого процесса свой кэш.

Разделяемая память: меняем malloc для хэш-таблицы на использование разделяемой памяти. Кэш-сервер "работает", но операции не атомарны.

Семафоры для атомарности операций.

TTL и процесс-сборщик мусора.

Если вы решили делать задание в предложенной последовательности, рекомендуется не приступать к следующему пункту, пока не сделан предыдущий.