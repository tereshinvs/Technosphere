Задание 6: многопоточный suggester.
Что хочется получить.
Suggester получает запросы по сети, на каждый запрос отдает строки из файла, которые начинаются с префикса, указанного в запросе.

Файл ("data.txt") состоит из записей вида "<строка> <вес>", записи разделяются переводом строки. "<вес>" — число, помещающееся в 32-битное целое.

Suggester принимает запросы на порт 4000. Запрос содержит только интересующий префикс, запросы разделяются переводом строки. Возвращаемые строки разделяются переводом строки, ответ заканчивается пустой строкой. Возвращать нужно не более 10 строк с максимальным весом, в порядке убывания веса.
Архитектура
Suggester должен обрабатывать запросы в worker потоках. Количество потоков фиксировано (например, 10), все потоки создаются при старте. Worker-потоки получают задания от основного потока через очереди. 

В worker-потоках должна осуществляться чтение/запись в сокеты, работа с файлами и кэширование. Основной поток accept-ит соединения и отдает их worker-ам.

С потоками можно работать при помощи std::thread / pthread_* / boost::thread.
Очередь заданий
Можно создавать либо по одной очереди заданий на каждый поток, либо одну очередь на все потоки. Первый вариант типично имеет несколько бóльшую производительность в контексте работы с самой очередью, второй позволяет распределять нагрузку между потоками более равномерно.

Очередь нужно реализовать при помощи mutex и condition variable (std/boost::mutex + std/boost::condition_variable / pthread_mutex_* + pthread_cond_*).
Кэш
Для ускорения отдачи ответа для частых запросов, нужно уметь кешировать результаты. Кэш разделяется между worker-потоками. Кэшировать нужно пары запрос-ответ.

Кэш ограничен по размеру, например закэшировано может быть не более 20Мб данных. Время жизни данных в кэше также ограничено. Например, при изменении файла данных, новые результаты начнут выдаваться через 10с.

При достижении максимального размера, старые данные должны вытесняться новыми. Для обеспечения ограничения времени жизни можно либо удалять старые записи в отдельном потоке, либо вытеснять их тем же механизмом, который обеспечивает ограничение по размеру.

В качестве структуры данных можно взять, например std::map/std::unordered_map. Синхронизация обеспечивается при помощи read-write lock (std/boost::shared_lock / pthread_rwlock_*). 


Последовательность действий.
Задание можно (но не обязательно) выполнять в следующей последовательности:

Однопоточный макет. Обрабатываем запросы по сети, возвращаем всегда одинаковый "тестовый" ответ.

Worker-потоки, многопоточный макет. Создаем очереди и пул потоков, обрабатываем запросы в пуле. Возвращаем по-прежнему "тестовый" ответ.

Suggester без кэша. Каждый раз читаем файл, возвращаем "правильный" ответ.

Кэш без ограничения по размеру/TTL. Всегда кешируем ответ.

Ограничение по размеру. Вытесняем старые данные из кэша.

Ограничение по TTL. Не возвращаем старые данные.
