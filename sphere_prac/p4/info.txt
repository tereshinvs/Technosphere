Задание 4: shell.
Что хочется получить.
Необходимо написать минималистичный shell, который поддерживает pipe и простые логические операции.

Shell читает инструкции с stdin и исполняет их. Инструкции разделяются переводом строки и состоят из отдельных вызовов разделенных операторами. Каждый вызов обязательно содержит команду, может содержать аргументы и перенаправления stdin/stdout. Аргументы разделяются между собой whitespace-символами. В конце команды может стоять "&", это значит, что команду нужно выполнить в фоновом режиме.

Вызовы нужно исполнять в отдельных процессах при помощи семейства вызовов exec, при этом, при поиске команды должна учитываться переменная PATH (нужно использовать execlp/execvp). 
Пример команды.
head <file.txt|sort    -n | cat > file.out && echo ok

"|" и "&&" — операторы, разделяющие вызовы. 
"head < file.txt", "sort -n", "cat > file.out" и "echo ok" — вызовы.
"head", "sort", "cat", "echo" — команды.
"-n", "ok" — аргументы.
"< file.txt", "> file.out" — перенаправления stdin и stdout соответственно.
Операторы.
Нужно поддержать операторы "|", "&&", "||". Операторы имеют одинаковый приоритет, однако они не ассоциативны и выражение нужно обязательно исполнять слева-направо. 

Exit-кодом отдельных вызовов будет значение, которое вернул вызов wait*().

<inv1> | <inv2> означает, что stdout <inv1> будет перенаправлен в stdin <inv2>, команды будут выполняться параллельно, exit-кодом всего выражения будет exit-код <inv2>.

<inv1> && <inv2> означает что нужно выполнить <inv2>, если exit-код <inv1> нулевой. Exit-кодом выражения будет код <inv2>, если оно было выполнено, в противном случае — exit-код <inv1>. У обеих команд будет одинаковый stdin/stdout.

<inv1> || <inv2> означает что нужно выполнить <inv2>, если exit-код <inv1> не нулевой. Exit-код и stdin/stdout реализуется аналогично предыдущему оператору
Фоновый режим.
В случае, если в конце команды стоит символ "&", нужно выполнить всю команду в отдельном процессе. При старте такой программы, shell должен напечатать на stderr "Spawned child process <pid>", где <pid> — pid дочернего процесса.

Shell должен обрабатывать завершение дочерних процессов и печатать на stderr "Process <pid> exited: <code>", где <pid> — <pid> дочернего процесса, а <code> — его exit-код. Завершение дочерних процессов можно обрабатывать перед вводом новой команды.
Перенаправление stdout.
В случае, если перенаправлен stdout, файл должен быть создан, если его нет и обнулен, если он существует. Файл также должен быть открыт в append-режиме.
Обработка SIGINT.
В случае, если shell получил сигнал SIGINT, выполнение команды должно быть остановлено. Кроме того, если мы ждем (или только запустили и собирались ждать) выхода дочернего процесса, SIGINT должен быть отправлен дочернему процессу. Это необходимо, чтобы CTRL+C в терминале завершал только текущую команду, а не весь shell целиком.
Последовательность действий.
Задание можно (но не обязательно) выполнять в следующей последовательности:
Обработка отдельных вызовов без операторов и перенаправлений.
Перенаправление stdin/stdout.
Реализация операторов "&&" и "||".
Реализация оператора "|".
Запуск и ожидание фоновых процессов.
Обработка SIGINT.

Каждый шаг тестируется тестовым скриптом ./run_tests по-отдельности.
Полезная информация.
Оператор "|" тривиально реализовать при помощи вызова pipe(). Переопределить дескрипторы stdin/stdout можно при помощи dup2().

Нужно, чтобы открытые дескрипторы не утекали в exec()-нутый процесс. Для этого может иметь смысл воспользоваться флагом FD_CLOEXEC.

Функция isatty() позволяет узнать привязан ли дексриптор к терминалу, при помощи нее можно узнать нужно ли печатать приглашение.

В задаче подразумевается рождение нескольких видов дочерних процессов, завершения которых нужно будет ожидать в разных местах. Возможно, будет удобным написать отдельный класс который позволит привязать callback к завершению конкретного процесса.

Семейство функций wait() по указателю на int возвращает не exit-код процесса, а более сложный набор полей, см. man.
Где брать тесты и куда/как сдавать.
Сдавать нужно Makefile и все необходимые исходные файлы. В исходном файле нужно в комментариях написать используемую архитектуру (Mac OS X/Linux). 

Тесты можно взять из репозитория на github: https://github.com/rvncerr/sfera-mail-mt/tree/master/practice